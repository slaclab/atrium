#!/usr/bin/env python3

import os
import re
import sys
import time
import math
import logging
import subprocess
import numpy as np

from epics import caget, camonitor, camonitor_clear

############################################
#             Global variables             #
############################################

# The BSA suffix for the system buffers are a combination of the destination
# suffix with the frequency suffix and the HST string. Example: HSTSCHTH
# The user buffers are just a number as suffix, so we are not using lists or
# dictionaries to represent them.

# SCD = SuperConducting to Diag0
# SCL = SuperConducting to Linac (BSY + HXR + SXR)
# SCB = SuperConducting to SC BSY Dump
# SCH = SuperConducting to Hard x-ray beamline 
# SCS = SuperConducting to Soft x-ray beamline 
bsa_dest_suffixes = ["SCD", "SCL", "SCB", "SCH", "SCS"]

# Dictionary that relates the frequency rate with the end of the system buffer name
bsa_freq_suffixes = {"1H": 1, "TH": 10, "HH": 100}

# Types of data/metadata to be stored in BSA PVs
bsa_hst_type_suffixes = ["HST","CNTHST","RMSHST","PIDHST"] 

# Types of data/metadata to be stored in BSSS PVs
bsss_scalar_type_suffixes = ["","CNT","RMS","PID"] 

# All types of data/metadata to be stored in BSA/BSSS PVs
acq_type_suffixes = bsa_hst_type_suffixes + bsss_scalar_type_suffixes

# BSA user buffer index range
bsa_usr_buff_range = np.arange(21,50)

# BSA fault buffer index range
bsa_flt_buff_range = np.arange(4)

# BSSS user buffer index range
bsss_usr_buff_range = np.arange(21,50)

# BSSS fault buffer index range
bsss_flt_buff_range = np.arange(4)

# Holds the specific PV prefix used by the IOC for each signal. Example: TST:SYS2:4:SIGNAL01
service_pv_prefixes = {"BSA": [], "BSSS": [], "BSAS": [], "BLD": []}

# Number of BSA data items to be used in test
ITEMS_PER_BSA_ARRAY = 10

# Logger object - CRITICAL, ERROR, WARNING, INFO, DEBUG
logger = logging.getLogger()
file_handler = logging.FileHandler("logfile.log")
file_handler.setLevel(logging.DEBUG)
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.DEBUG)
logger.addHandler(file_handler)
logger.addHandler(console_handler)
logger.setLevel(logging.DEBUG)

#TODO: case when cpu name is wrong
# Pass cpu name as argument
# Make number of bsa items to test an argument

first_collected = second_collected = False
signal_data1 = signal_data2 = []

############################################
#           Classes follow below           #
############################################

#************ CMD_SEEKER Class ************#
class CMD_SEEKER:
    """
    
    This class will look for the st.cmd script.

    """

    def __init__(self):
        print("Initializing CMD_SEEKER\n")

    def get_cmd(self):
        if len(sys.argv) <= 1:
            cpu = input("CPU name where the IOC to be tested is running:\n")
        else:
            cpu = str(sys.argv[1])

        # Run screen -ls in cpu
        ssh_ls = subprocess.run(["ssh", "laci@" + cpu, "screen -ls"], capture_output=True)
        screen_lines = ssh_ls.stdout.decode()
        # Separate the line breaks from screen -ls
        screen_lines = screen_lines.split("\n")
        
        print("\nIOCs found running in " + cpu + ":")
        
        iii = 1
        iocs = []
        for line in screen_lines:
            # We look only on lines that have the string ioc
            if "ioc" in line:
                # screen -ls returns with the following format:
                # 2158.sioc-b084-gd02     (Detached)
                ioc = line.split(".")
                ioc = ioc[1].split("\t")
                ioc = ioc[0]
                print ("( " + str(iii) + " ) " + ioc)
                iocs.append(ioc)
                iii += 1
        
        valid_choice = False
        
        while not valid_choice:
            ioc_choice = input("\nChoose the number of the IOC to test: ")
            try:
                ioc = iocs[int(ioc_choice) - 1]
            except:
                print(ioc_choice + " is not a valid number. Try again, please.")
            else:
                valid_choice = True
        
        print()
        print("Please, wait a few seconds, I'm reading the st.cmd file.")
        
        st_cmd_exists = False
        
        ioc_path = os.environ["IOC"] + "/" + ioc + "/iocSpecificRelease/iocBoot/"
        path_exists = os.path.exists(ioc_path)
        if path_exists:
            for root, dirs, files in os.walk(ioc_path):
                for dir in dirs:
                    if dir == ioc:
                        ioc_path = os.path.join(root, dir, "st.cmd")
                        st_cmd_exists = True
        
        if st_cmd_exists:
            # Read the entire st.cmd, expanding sub cmd files
            st_cmd = subprocess.run(["/afs/slac/u/gu/egumtow/scripts/iocsh_lines.sh", ioc_path], capture_output=True)
            st_cmd = st_cmd.stdout.decode().split("\n")
            return st_cmd
        else:
            print("I'm sorry, I can't seem to find the st.cmd in " + ioc_path)
            print("How is this possible?")
            print("I give up and I'm exiting.")
            exit(1)

#************ CMD_PARSER Class ************#
class CMD_PARSER:
    """
    
    This class will parse the st.cmd script.

    """
    
    def __init__(self):
        print("Initializing CMD_PARSER\n")

    def apply_substitutions(self, line, envSets):
        # Search for ${MACRONAME}
        pattern = "\$\{(\w*)\}"
        macros = re.findall(pattern, line)
        # Search for macros present in the line and replace with data
        # available from the dictionary.
        for macro in macros:
            if macro in envSets:
                value = envSets[macro]
                line = line.replace("${" + macro + "}", value)
        return line

    def extract_service_pv_prefix(self, line, service):
        # We are processing a line like
        # dbLoadRecords("db/bsa.db", "DEV=EM2K0:XGMD:HPS,PORT=bsaPort,BSAKEY=YFIXEDPAMC1,SECN=POSY")
        # and want to extract all pairs macro=value present in the line.
        pattern = '[",]?([\w]+)=([\w:]*)[,"]'
        pairs = re.findall(pattern, line)
        dev = secn = ""
        for macro, value in pairs:
            if macro == "DEV":
                dev = value
            if macro == "SECN":
                secn = value

        service_pv_prefixes[service].append(dev + ":" + secn)

    def parse_cmd(self, st_cmd):
        envSets = {}
        for line in st_cmd:
            if "epicsEnvSet" in line:
                # Format of epicsEnvSet is
                # epicsEnvSet("ST_CMD"   ,"startup.cmd")
                env_def = line.split("(")
                env_def = env_def[1].split(",")
                env_key = env_def[0].split('"')[1]
                env_value = env_def[1].split('"')[1]
                # Expand macros if they exist
                env_value = self.apply_substitutions(env_value, envSets)
                envSets[env_key] = env_value
            if "bsa.db" in line:
                line = self.apply_substitutions(line, envSets)
                self.extract_service_pv_prefix(line, "BSA")
            if "bsss.db" in line:
                line = self.apply_substitutions(line, envSets)
                self.extract_service_pv_prefix(line, "BSSS")
            if "bsas.db" in line:
                line = self.apply_substitutions(line, envSets)
                self.extract_service_pv_prefix(line, "BSAS")
            if "bld.db" in line:
                line = self.apply_substitutions(line, envSets)
                self.extract_service_pv_prefix(line, "BLD")
        #print(envSets)
        #print(caget(service_pv_prefixes["BSA"][0] + "PIDSCD1H"))
        #print(service_pv_prefixes)
        print("\nst.cmd reading complete.\n")

#************ BSA_TESTER Class ************#
class BSA_TESTER:
    """
    
    This class will test the BSA buffers.

    """
    
    def __init__(self):
        print("Initializing BSA_TESTER\n")

    def on_monitor(self, pv_name=None, value=None, **kw):
        global first_collected, second_collected
        #print("Running callback on_monitor:")
        if not first_collected:
            global signal_data1 
            signal_data1 = value
            first_collected = True
            print("First sample  --> "+str(value))
        elif not second_collected:
            global signal_data2
            signal_data2 = value
            second_collected = True
            print("Second sample --> "+str(value))

    def estimate_sleep_time(self):
        # Sample data at different rates to determine wait time until next update
        return 1.25

    def get_pv_data(self, pv_name): 
        # Read the PV twice, so we can compare if they changed
        global first_collected
        global second_collected
        first_collected = second_collected = False
        camonitor(pv_name, callback=self.on_monitor)
        sleep_time = self.estimate_sleep_time()
        while (not first_collected) or (not second_collected):
            time.sleep(sleep_time)
        camonitor_clear(pv_name)

    def check_pair_for_packed_pv_data(self, pv_name):
        # Check if both samples are populated with data
        if (isinstance(signal_data1, (list, tuple, np.ndarray)) and (len(signal_data1) == 0 or len(signal_data2) == 0)) or \
           (not isinstance(signal_data1, (list, tuple, np.ndarray)) and (np.array(signal_data1).size == 0 or np.array(signal_data2).size == 0)):
            logger.error("[ERROR] - " + pv_name + " didn't bring any data (empty).")
            logger.error("          Is BSA working?")

    def check_pair_for_diff_pv_data(self, pv_name):
        # Check if the bsa buffers changed in time.
        if np.array_equal(np.array(signal_data1), np.array(signal_data2)):
            logger.critical("[CRITICAL] - " + pv_name + " is not updated with new values.")
            logger.critical("             Sampling too fast or is the PV value constant?")
            
    def check_for_updated_pv_data(self, pv_name):
        # Check to see if we always get the same value in the latest sample 
        if (isinstance(signal_data2, (list, tuple, np.ndarray)) and (np.array(signal_data2) == np.array(signal_data2)[-1]).all()) or \
           (not isinstance(signal_data2, (list, tuple, np.ndarray)) and (np.array(signal_data2) == np.array([signal_data2])[-1]).all()):
            logger.warning("[WARNING] - " + pv_name + " keeps the same value over time.")
            logger.warning("            Is IOC triggering the firmware correctly?")

    def check_for_nan_pv_data(self, pv_name):
        # Check for at least one NaN value
        if np.isnan(np.sum(signal_data1)) or np.isnan(np.sum(signal_data2)):
            logger.error("[ERROR] - " + pv_name + " contains NaN values.")

    def test_bsa_signal_change_in_time(self, pv_name):
        # Sample PV data
        self.get_pv_data(pv_name)
        # Check for NaN values
        self.check_for_nan_pv_data(pv_name)
        # Check if both samples are populated with data
        self.check_pair_for_packed_pv_data(pv_name)
        # Check if the bsa buffers changed in time.
        self.check_pair_for_diff_pv_data(pv_name)
        # Check to see if we always get the same value in the latest sample 
        self.check_for_updated_pv_data(pv_name)
    
    def test_bsss_signal_change_in_time(self, pv_name):
        # Sample PV data
        self.get_pv_data(pv_name)
        # Check for NaN values
        self.check_for_nan_pv_data(pv_name)
        # Check if both samples are populated with data
        self.check_pair_for_packed_pv_data(pv_name)
        # Check if the bsa buffers changed in time.
        self.check_pair_for_diff_pv_data(pv_name)

    def test_bsa_system_buffers(self):
        print("Checking BSA system buffers. This may take some time.")
        list_of_signal_pvs = service_pv_prefixes["BSA"]
        self.test_system_buffers(list_of_signal_pvs, bsa_hst_type_suffixes, self.test_bsa_signal_change_in_time) 

    def test_bsss_system_buffers(self):
        print("Checking BSSS system buffers. This may take some time.")
        list_of_signal_pvs = service_pv_prefixes["BSSS"]
        self.test_system_buffers(list_of_signal_pvs, bsss_scalar_type_suffixes, self.test_bsss_signal_change_in_time) 
    
    def test_bsa_user_buffers(self):
        print("TBD - Test bsa user buffers")
    
    def test_bsss_user_buffers(self):
        print("TBD - Test bsss user buffers")
    
    def test_bsa_fault_buffers(self):
        print("TBD - Test bsa fault buffers")
    
    def test_bsss_fault_buffers(self):
        print("TBD - Test bsss fault buffers")
    
    def test_system_buffers(self, signal_pvs, service_type_suffixes, fcn_test_signal_change_in_time):
        for signal_pv in signal_pvs:
            for dest_suffix in bsa_dest_suffixes:
                print("\n--------------------------------------------")
                print("Testing " + dest_suffix + " for " + signal_pv)
                print("--------------------------------------------")
                for freq_suffix, freq in bsa_freq_suffixes.items():
                    for svc_type in service_type_suffixes: 
                        # Form the PV name
                        pv = signal_pv + svc_type + dest_suffix + freq_suffix# + ".[-" + str(ITEMS_PER_BSA_ARRAY) + ":]"
                        print("\n*****< " + pv + " >*****\n")
                        
                        # Test 1: check for signal change over time
                        fcn_test_signal_change_in_time(pv)
                        
                        # Test 2: check for ...
                        
                        # Test 3: check for ...
                        
                        # Test 4: check for ...
                        
                        # Test 5: check for ...
                        
                        # Test 6: check for ...
                    
                        # Test 7: check for ...
                        
                        # Test 8: check for ...

############################################
#         __main__ block goes here         #
############################################
if __name__ == "__main__":
    
    # Create a seeker object for .cmd files
    seeker = CMD_SEEKER()
    cmd = seeker.get_cmd()
    
    # Create a parser object for .cmd files
    parser = CMD_PARSER()
    parser.parse_cmd(cmd)
     
    # Create a tester object for BSA buffers
    tester = BSA_TESTER()

    tester.test_bsa_system_buffers  ()
    tester.test_bsss_system_buffers ()
    
    tester.test_bsa_user_buffers    ()
    tester.test_bsss_user_buffers   ()
    
    tester.test_bsa_fault_buffers   ()
    tester.test_bsss_fault_buffers  ()
